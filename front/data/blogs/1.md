# Login status -- cookies、 session、 token
## backgroud

We all know that http is stateless, which means that the state cannot be maintained between the requester and the responder, it is all one-time, and he does not know what happened before the request. However, in some application scenarios, we need to maintain the status. For example, various background management systems need to log in to perform various operations. At this time, we need to maintain the user's login status.

Common login schemes are:

1.cookies+session

2.json web token(JWT)

## cookie and session

Cookies are a type of front-end storage, but compared to other methods such as localStorage, with the help of HTTP headers and browser capabilities, cookies can be front-end unaware。

The general process is like this：

- In the interface that provides the markup, directly "seed" to the browser through the Set-Cookie field of the HTTP return header。
- When the browser initiates a request, it will automatically bring the cookie to the interface through the Cookie field of the HTTP request header。
- The server and the SessionId field in the cookie query the user session data of the user to which the current request belongs。

### cookie config

- **Domain / Path**
  The Domain attribute specifies which domains should be attached with this cookie when the browser makes an HTTP request. If this attribute is not specified, the browser will set it as the first-level domain name of the current URL by default. For example, http://www.example.com will be set to http://example.com, and if you visit http:// Any subdomain of example.com, HTTP requests will also carry this cookie. If the domain name specified by the server in the Set-Cookie field does not belong to the current domain name, the browser will reject the cookie.
  The Path attribute specifies which paths to attach this cookie to when the browser makes an HTTP request. As long as the browser finds that the Path attribute is the first part of the HTTP request path, it will include this cookie in the header information. For example, if the PATH attribute is /, then the request /docs path will also include the cookie. Of course, the premise is that the domain name must be consistent。

- **Expires / Max-Age**
  The Expires attribute specifies a specific expiration time. After the specified time, the browser will no longer retain the cookie. Its value is in UTC format. If this property is not set, or set to null, the cookie is only valid in the current session. Once the browser window is closed and the current session ends, the cookie will be deleted. In addition, the browser determines whether the cookie expires according to the local time. Since the local time is imprecise, there is no way to guarantee that the cookie will expire at the time specified by the server.
  The Max-Age property specifies the number of seconds the cookie will exist from now on, such as 60 _ 60 _ 24 \* 365 (that is, one year). After this time, the browser will no longer keep this cookie.
  If both Expires and Max-Age are specified, the value of Max-Age will take precedence.
  If the Set-Cookie field does not specify the Expires or Max-Age attribute, then this cookie is a session cookie, that is, it only exists in this session. Once the user closes the browser, the browser will no longer retain this cookie。

- **Secure / HttpOnly**
  The Secure attribute specifies that the browser can only send this cookie to the server under the encrypted protocol HTTPS. On the other hand, if the current protocol is HTTP, the browser will automatically ignore the Secure attribute sent by the server. This property is just a switch, no value needs to be specified. This switch is automatically turned on if the communication is HTTPS protocol.
  The HttpOnly attribute specifies that the cookie cannot be obtained through JavaScript scripts, mainly because the Document.cookie attribute, XMLHttpRequest object and Request API cannot obtain this attribute. This prevents the cookie from being read by the script, and the cookie is only included when the browser makes an HTTP request。

### server session

Session originally refers to the session state between the client and the server. Since the credentials are stored on the server, the information stored on the server is later called session.
Now the server maintains the login state by itself, only sends a key to the client, and then maintains a key-value table in itself. If there is a key in the request and the corresponding value can be found in the table, it is considered legal。

### Questions

#### 1.Cluster server session synchronization

The session can be extracted for unified management, such as using Redis services

#### 2.There is no way to avoid CSRF attacks

#### 3.Cookies for cross-domain requests

#### 4.cookie sharing

Cookie sharing under the same domain name.

## jWT

Using JWT to maintain the login state, the server no longer needs to maintain the state table. It only sends an encrypted data token to the client, and each request brings this encrypted data, and then decrypts it to verify whether it is legal. Since it is encrypted data, even if the user can modify it, the chance of hit is very small.

### Simple example of JWT in node

As a first step, use the jsonwebtoken middleware in your /login route to generate tokens：

```
const jwt = require('jsonwebtoken')
let token = jwt.sign({
  name: user name
  }, config.secret, {
  expiresIn: '24h'
})
res.cookie('token', token)
```

The second step is to register the express-jwt middleware in Node's entry file app.js to verify the token:

```
const expressJwt = require('express-jwt')
app.use(expressJwt({
  secret: config.secret,
  getToken: (req) => {
    return req.cookies.token || null
  }
}).unless({
  path: [
  '/login'
  ]
}))
```
If getToken returns null, the middleware will throw an UnauthorizedError exception:

```
app.use(function (err, req, res, next) {
//When the token verification fails, the following error will be thrown
if (err.name === 'UnauthorizedError') {
      res.status(401).json({
      status: 'fail',
      message: 'Identity verification expired, please log in again'
    });
  }
});
```
