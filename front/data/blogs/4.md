# umi practice question set # React team open source a new performance analysis tool - Scheduling Profiler !

Recently, the React team open sourced a new performance analysis tool -- Scheduling Profiler

! [avatar](/static/images/schedulingProfiler.jpg)

React's previous Profiler mainly analyzed the performance of components while rendering. It didn't tell us what React was doing (the actual collaborative scheduling bit). As the React Scheduler has grown more powerful, it no longer meets our analysis needs, and the new Profiler can show when components schedule state updates and when React processes them. It can also show how React categorizes and prioritizes the content it works on.

For example, here is a simple application that uses only the old (synchronized) ReactDOM.renderAPI. The parser shows that all the work scheduled and rendered by this application is done with synchronous priority.

It uses the new createRoot API to render at the default priority, and then synchronously updates to respond to an input event to manage a controlled component:

This is part of the profile that shows the idle application (no JavaScript running). In this case, React does some pre-rendering for the offscreen (not currently displayed) component.

**offscreen is a new API not yet released for React 18**

## How transitions work

startTransition is a new API added to React 18 that allows you to distinguish between non-urgent state updates. All updates in the startTransition callback are considered non-urgent, and if there is a more urgent update (such as the user entering a new value), the above update is interrupted until there are no other urgent actions before continuing.

Here's an example using the startTransition API: React renders a small update first, showing the user some visual feedback (e.g. Loading state)

! [avatar](/static/images/1.jpg)

How does ## Suspense affect rendering performance?

The React team expects to release full support for fetching data via Suspense sometime after React 18.0, but you can now use Suspense to handle things like delayed loading of React components. The new parser shows how long components are paused during rendering and how this affects overall rendering performance.

For example, here's an example that uses React.lazy to load a component. While this component is loading, React displays a placeholder. Once the component finishes loading, React will retry rendering and commit the final UI.

! [avatar](/static/images/3.jpg)

## What else might cause rendering delays?

Suspense can cause rendering delays as React waits for data to load, but React can also get stuck waiting for a lot of JavaScript to run.

The React parser tool used to focus only on analyzing what React (or a React component) was doing, but any JavaScript the browser is running can affect performance. The new parser also shows non-React JavaScript, so it's easy to see when it's delaying the rendering of React.

! [avatar](/static/images/2.jpg)

## Tips for improving performance

The old parser just focused on doing some analysis, but the new version of the tool can give us some optimization tips: !

! [avatar](/static/images/5.jpg)

Also the new parser warns about scheduling long synchronous React updates in event handlers: !


! [avatar](/static/images/4.jpg)

Development Environment.
umi: 3.5.18
node: v14.15.1
System: windows

This article mainly records some scenario-specific issues during the project practice, for reference only: ## 1.

## 1. webpackChain custom loader error: this.getOptions is not a function

** Scenario:**
    Add loader to parse makdown file to html display, use webpackChain to add remark-loader,html-loader to report error.
```
export default {
    ...
    chainWebpack(config){
        config.module
        .rule('compile-md')
        .test(/\.md$/)
            .use("html-loader")
            .loader("html-loader")
            .end()
            .use("markdown-loader")
    }
    ...
}
  
```
**Solution:**
    Just close the webpack5 editor and modify the umi configuration config.js or .umirc.js to.
```
export default {
    ...
    webpack5:false,
    ...
}
```

## 2. mfsu, @umijs/preset-ui(block) are not supported under SSR(server-side rendering)

## 3. SSR (server-side rendering) after the first request, click on the navigation menu, the route switch occurs to jump to a new page did not launch a request to the server to get a new page, but a locally done page re-rendering.
**Solution:**
Replace the NavLink component with a tag

## 4. SSR (Server Side Rendering) requests server Css and js files and returns html content.
**Solution:**
If you configure hash:true, turn off the hash function of the packaged file, because umi.server.js does not add hash to the reference address of js and css, for example, your packaged file name is umi.adsjsnd.css, but the reference file name of umi.server.js to css is umi.css, Modify the configuration config.js or .umirc.js to
```
export default {
    ...
    hash:false
    ...
}
```
 If hash:true is not configured, refer to this issues:https://github.com/umijs/umi/issues/4808

 ## 5. Enable mfsu:{} error: 1. Can't read property 'ModuleFederationPlugin' of undefined.
 **Solution:**
 Please make sure mfsu:{} is added to config.ts instead of config.dev.ts or config.prod.ts.