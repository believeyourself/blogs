<!--
 * @Date: 2022-01-20 14:27:07
 * @LastEditors: lzj
 * @LastEditTime: 2022-01-21 16:41:33
 * @FilePath: \qianduan.shop\front\src\pages\document.ejs
--><!DOCTYPE html><html><head><title data-react-helmet="true">react cron表达式生成组件qnn-react-cron - 前端网</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no">
    <script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2087076429727327" crossorigin="anonymous"></script>
    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico">
    <link rel="stylesheet" href="/umi.css">
    <link rel="stylesheet" href="/layouts.chunk.css">
    <link rel="stylesheet" href="/p__blogs__detail__detail.chunk.css">
    <script>
      window.routerBase = "/";
    </script>
    <script>
      //! umi version: 3.5.18
    </script>
    <title>文章详情</title>
  <meta data-react-helmet="true" name="description" content="前端网,react,antd,cron表达式,介绍react实现的cron表达式生成组件qnn-react-cron以及其前身组件react-cron-antd"><meta data-react-helmet="true" name="keywords" content="前端网,react,antd,cron表达式">
</head>

  <body>
    <div id="root"><header class="header___2_57M"><img alt="farmerLZJ" class="title___MhkPP" src="/static/logo.68ff92ec.png"/></header><div style="width:100%;position:relative;top:0;z-index:999"><nav class="nav___3wfA1"><a href="https://izejun.com/blogs" class="item___AqKVH active___1THnk">博客</a></nav></div><div class="content___2QN8t"><div class="content___1G4Bw"><header><a href="https://izejun.com/" class="back___26SyS undefined"> <!-- -->首页</a> <!-- -->/<a href="https://izejun.com/blogs" class="back___26SyS undefined"> <!-- -->博客</a></header><article><h1>react cron表达式生成组件qnn-react-cron</h1>

<p>最近需求遇到了需要用户配置cron表达式的需求，又不能让用户直接输入 <strong>&quot;0/10 <em> </em> <em> </em> ? *&quot;</strong> 这种字符串形式的cron表达式，只能通过可视化界面帮助用户生成表达式，鉴于生成逻辑还是比较复杂，于是就开始在网上找现成的轮子来使用。</p>

<p>这里主要介绍两个组件react-cron-antd和qnn-react-cron, 先说结果，我们最终选择qnn-react-cron,因为它bug相对少，支持多语言，就是这样，原因后面细说。</p>

<p>qnn-react-cron改编自react-cron-antd，所以两个组件的功能是一样的，都支持以下功能：</p>

<p>🎉 全面支持cron：秒、分、时、日、月、周、年
🎉 日及周条件互斥，自动改变响应值
🎉 支持反解析cron表达式到UI
🎉 可结合此组件与Antd的下拉及输入组件封装成下拉输入框🎉 全面支持cron：秒、分、时、日、月、周、年
🎉 日及周条件互斥，自动改变响应值
🎉 支持反解析cron表达式到UI
🎉 可结合此组件与Antd的下拉及输入组件封装成下拉输入框</p>

<p>显示效果也是一样的：</p>

<p><img alt="react cron组件效果图" src="/static/images/7.jpg"/></p>

<p>那为什么qnn-react-cron的作者要去改编reract-cron-antd组件呢？</p>

<p>因为react-cron-antd作者长时间未更新组件，导致组件无法正常引用，qnn-react-cron除了修复了不能组件不能使用的问题外，在原基础增加：getCronFns、footer 属性使组件更加灵活，修改 value 值传入后或者更新后自动重新渲染。</p>

<p>github上react-cron-antd还有几个尚未解决的issues:</p>

<p>&lt;img alt=&quot;react-cron-antd issues&quot; src=&quot;/static/images/8.png&quot; width=&quot;100%&quot; /&gt;</p>

<p>就在最近几天qnn-react-cron支持了多语言，更Nice了。恰好我们项目需要支持多语言，简直太及时！！</p>

<h2>qnn-react-cron 如何使用</h2>

<p>直接上代码：</p>

<p><code></code>`
import React from &quot;react&quot;;
import Cron from &quot;qnn-react-cron&quot;;</p>

<p>// 可使用 QnnReactCron.Provider 配置国际化语言
// 无需配置语言时，可不使用  QnnReactCron.Provider
// QnnReactCron.Provider 应该包裹于入口组件以实现全部路由下的组件内部语言都被自定义</p>

<p>export default ()=&gt;{</p>

<pre><code>// language 为可选参数， 具体配置如下
const language = {

    // 面板标题
    paneTitle:{
        second: &quot;秒&quot;,
        minute: &quot;分&quot;,
        hour: &quot;时&quot;,
        day: &quot;日&quot;,
        month: &quot;月&quot;,
        week: &quot;周&quot;,
        year: &quot;年&quot;,
    },

    // assign  指定
    assign: &quot;指定&quot;,
    // Don&#39;t assign  不指定
    donTAssign: &quot;不指定&quot;,

    // Every minute ...   每一秒钟、每一分钟
    everyTime: {
        second: &quot;每一秒钟&quot;,
        minute: &quot;每一分钟&quot;,
        hour: &quot;每一小时&quot;,
        day: &quot;每一日&quot;,
        month: &quot;每一月&quot;,
        week: &quot;每一周&quot;,
        year: &quot;每年&quot;,
    },

    // from [a] to [b] [unit], executed once [unit]    a 到 b 每一个时间单位执行一次
    aTob: {
        second: (AInput, BInput) =&gt; (
            &lt;span&gt;
                从{AInput}-{BInput}秒，每秒执行一次
            &lt;/span&gt;
        ),
        minute: (AInput, BInput) =&gt; (
            &lt;span&gt;
                从{AInput}-{BInput}分，每分钟执行一次
            &lt;/span&gt;
        ),
        hour: (AInput, BInput) =&gt; (
            &lt;span&gt;
                从{AInput}-{BInput}时，每小时执行一次
            &lt;/span&gt;
        ),
        day: (AInput, BInput) =&gt; (
            &lt;span&gt;
                从{AInput}-{BInput}日，每日执行一次
            &lt;/span&gt;
        ),
        month: (AInput, BInput) =&gt; (
            &lt;span&gt;
                从{AInput}-{BInput}月，每月执行一次
            &lt;/span&gt;
        ),
        week: (AInput, BInput) =&gt; (
            &lt;span&gt;
                从{AInput}-{BInput}，每星期执行一次
            &lt;/span&gt;
        ),
        year: (AInput, BInput) =&gt; (
            &lt;span&gt;
                从{AInput}-{BInput}年，每年执行一次
            &lt;/span&gt;
        ),
    },

    // from [a] [unit] start, every [b] Execute once [unit]   从 a 开始, 每一个时间单位执行一次
    aStartTob: {
        second: (AInput, BInput) =&gt; (
            &lt;span&gt;
                从{AInput}秒开始，每{BInput}秒执行一次
            &lt;/span&gt;
        ),
        minute: (AInput, BInput) =&gt; (
            &lt;span&gt;
                从{AInput}分开始，每{BInput}分执行一次
            &lt;/span&gt;
        ),
        hour: (AInput, BInput) =&gt; (
            &lt;span&gt;
                从{AInput}时开始，每{BInput}小时执行一次
            &lt;/span&gt;
        ),
        day: (AInput, BInput) =&gt; (
            &lt;span&gt;
                从{AInput}日开始，每{BInput}日执行一次
            &lt;/span&gt;
        ),
        month: (AInput, BInput) =&gt; (
            &lt;span&gt;
                从{AInput}月开始，每{BInput}月执行一次
            &lt;/span&gt;
        ),

        // [n] in the NTH week of this month    本月第 n 周的 星期[n] 执行一次
        week: (AInput, BInput) =&gt; (
            &lt;span&gt;
                本月第{AInput}周的{BInput}执行一次
            &lt;/span&gt;
        ),

        // 本月的最后一个 星期[n] 执行一次
        week2: (AInput) =&gt; &lt;span&gt;月的最后一个{AInput}执行一次&lt;/span&gt;,

        year: (AInput, BInput) =&gt; (
            &lt;span&gt;
                从{AInput}年开始，每{BInput}年执行一次
            &lt;/span&gt;
        ),
    }

};

return &lt;QnnReactCron.Provider value={{language}}&gt;
        &lt;Cron
            value=&quot;* * * * * ? *&quot;

            // 未自定义底部按钮时，用户点击确认按钮后的回调
            onOk={(value) =&gt; {
                console.log(&quot;cron:&quot;, value);
            }}

            // 相当于 ref
            getCronFns={(fns) =&gt; {
                // 获取值方法
                // fns.getValue: () =&gt; string

                // 解析Cron表达式到UI 调用该方法才可以重新渲染 【一般不使用】(value值改变后组件会自动更新渲染)
                // fns.onParse: () =&gt; Promise().then(()=&gt;void).catch(()=&gt;()=&gt;void),
                this.fns = fns;
            }}

            // 自定义底部按钮后需要自行调用方法来或者值
            footer={
                [
                    //默认值
                     &lt;Button style={{ marginRight: 10 }} onClick={()=&gt;this.fns.onParse}&gt;
                        解析到UI
                     &lt;/Button&gt;
                    &lt;Button type=&quot;primary&quot;  onClick={()=&gt;console.log(this.fns.getValue)}&gt;
                        生成
                    &lt;/Button&gt;
                ]
            }
        /&gt;
&lt;/QnnReactCron.Provider&gt;</code></pre>

<p>}
<code></code>`</p>

<p>最后附上github地址：&lt;a href=&quot;https://github.com/wangzongming/qnn-react-cron&quot; rel=&quot;nofollow&quot; &gt;https://github.com/wangzongming/qnn-react-cron&lt;/a&gt;</p>

<p>用起来还有一个小缺憾就是在ts中没有类型声明文件可以用，有兴趣的同学可以去搞一个发布出来。</p></article><div><span class="ant-tag ant-tag-geekblue">#<span>react</span></span><span class="ant-tag ant-tag-volcano">#<span>antd</span></span><span class="ant-tag ant-tag-error">#<span>cron表达式</span></span></div><div class="ant-divider ant-divider-horizontal" role="separator"></div><div class="ant-divider ant-divider-horizontal" role="separator"></div><ins class=" adsbygoogle" style="display:block;text-align:center;width:100%;height:90px" data-ad-client="ca-pub-2087076429727327" data-ad-slot="9331479126" data-ad-layout="" data-ad-layout-key="" data-ad-format="auto" data-full-width-responsive="false"></ins></div><div class="container___8WoUM"><p class="title___3k8xL">Online Tools</p><div class="tool_tags___1ccK5"><span class="ant-tag ant-tag-blue tool_tag___1JT6M">JSON Formater</span><span class="ant-tag ant-tag-cyan tool_tag___1JT6M">MD5</span><span class="ant-tag ant-tag-error tool_tag___1JT6M">timestamps</span><span class="ant-tag ant-tag-green tool_tag___1JT6M">Cron Expresstion</span></div><div class="ant-divider ant-divider-horizontal" role="separator"></div><div style="text-align:center;height:300px"><ins class=" adsbygoogle" style="display:inline-block;width:250px;height:300px" data-ad-client="ca-pub-2087076429727327" data-ad-slot="7022357395" data-ad-layout="" data-ad-layout-key="" data-ad-format="auto" data-full-width-responsive="false"></ins></div><div class="ant-divider ant-divider-horizontal" role="separator"></div><div style="text-align:center;height:300px"><ins class=" adsbygoogle" style="display:inline-block;width:250px;height:300px" data-ad-client="ca-pub-2087076429727327" data-ad-slot="7022357395" data-ad-layout="" data-ad-layout-key="" data-ad-format="auto" data-full-width-responsive="false"></ins></div></div></div><footer class="footer___3wR6c">©2021 farmerlzj 提供技术支持 | 联系我们：farmerlzj@163.com |<!-- --> <a href="https://beian.miit.gov.cn/" rel="nofollow" target="_blank">蜀ICP备2021025378号-1</a></footer><div class="ant-back-top"></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script src="https://cloud.qianduan.shop/react.min.js"></script>
    <script src="https://cloud.qianduan.shop/react-dom.min.js"></script>
    <script src="/umi.js"></script>
    <script src="/layouts.js"></script>
    <script src="/p__blogs__detail__detail.js"></script>
  

</body></html>