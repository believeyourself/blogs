<!--
 * @Date: 2022-01-20 14:27:07
 * @LastEditors: lzj
 * @LastEditTime: 2022-01-21 16:41:33
 * @FilePath: \qianduan.shop\front\src\pages\document.ejs
--><!DOCTYPE html><html><head><title data-react-helmet="true">React 中 useEffect 和 useLayoutEffect 作用和区别 - 前端网</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no">
    <script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2087076429727327" crossorigin="anonymous"></script>
    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico">
    <link rel="stylesheet" href="/umi.css">
    <link rel="stylesheet" href="/layouts.chunk.css">
    <link rel="stylesheet" href="/p__blogs__detail__detail.chunk.css">
    <script>
      window.routerBase = "/";
    </script>
    <script>
      //! umi version: 3.5.18
    </script>
    <title>文章详情</title>
  <meta data-react-helmet="true" name="description" content="react,useEffect,useLayoutEffect,日常开发中的大部分情况下，使用 useEffect 就可以帮我们处理组件的副作用，但是如果想要同步调用一些副作用，比如对 DOM 的操作，就需要使用 useLayoutEffect，useLayoutEffect 中的副作用会在 DOM 更新之后同步执行,useLayoutEffect 与原来 class 组件原来的 componentDidMount &amp; componentDidUpdate 一样，会在 react 完成 DOM 更新后马上同步调用的代码，会阻塞页面渲染。"><meta data-react-helmet="true" name="keywords" content="react,useEffect,useLayoutEffect">
</head>

  <body>
    <div id="root"><header class="header___2_57M"><img alt="farmerLZJ" class="title___MhkPP" src="/static/logo.68ff92ec.png"/></header><div style="width:100%;position:relative;top:0;z-index:999"><nav class="nav___3wfA1"><a href="https://izejun.com/blogs" class="item___AqKVH active___1THnk">Blog</a></nav></div><div class="content___2QN8t"><div class="content___1G4Bw"><article><h1>React 中 useEffect 和 useLayoutEffect 作用和区别</h1>

<p>日常开发中的大部分情况下，使用 useEffect 就可以帮我们处理组件的副作用，但是如果想要同步调用一些副作用，比如对 DOM 的操作，就需要使用 useLayoutEffect，useLayoutEffect 中的副作用会在 DOM 更新之后同步执行,useLayoutEffect 与原来 class 组件原来的 componentDidMount &amp; componentDidUpdate 一样，会在 react 完成 DOM 更新后马上同步调用的代码，会阻塞页面渲染。</p>

<p>下面的例子中，useLayoutEffect 会在 render，DOM 更新之后同步触发函数，会优于 useEffect 异步触发函数。</p>

<p><code>
function Demo() {
  const [width, setWidth] = useState(0);
  useLayoutEffect(() =&gt; {
    const title = document.querySelector(&quot;#title&quot;);
    const titleWidth = title.getBoundingClientRect().width;
    console.log(&quot;useLayoutEffect&quot;);
    if (width !== titleWidth) {
      setWidth(titleWidth);
    }
  });
  useEffect(() =&gt; {
    console.log(&quot;useEffect&quot;);
  });
  return (
    &lt;div&gt;
      &lt;h1 id=&quot;title&quot;&gt;hello&lt;/h1&gt;
      &lt;h2&gt;{width}&lt;/h2&gt;
    &lt;/div&gt;
  );
}
</code></p>

<h2>官方建议优先使用 useEffect</h2>

<p>在实际使用时如果想避免页面抖动（在useEffect里修改DOM很有可能出现）的话，可以把需要操作DOM的代码放在useLayoutEffect里。关于使用useEffect导致页面抖动，参考git仓库git仓库示例。</p>

<p>不过 useLayoutEffect 在服务端渲染时会出现一个warning，要消除的话得用useEffect代替或者推迟渲染时机。</p>

<h2>服务端渲染（ssr）</h2>

<p>在服务端渲染组件中引入 useLayoutEffect 代码时会触发 React 告警, 因为无论 useLayoutEffect 还是 useEffect 都无法在 Javascript 代码加载完成之前执行。要解决这个问题，需要将代码逻辑移至 useEffect 中（如果首次渲染不需要这段逻辑的情况下），或是将该组件延迟到客户端渲染完成后再显示（如果直到 useLayoutEffect 执行之前 HTML 都显示错乱的情况下）。</p>

<p>若要从服务端渲染的 HTML 中排除依赖布局 effect 的组件，可以通过使用 showChild &amp;&amp; &lt;Child /&gt; 进行条件渲染，并使用 useEffect(() =&gt; { setShowChild(true); }, []) 延迟展示组件。这样，在客户端渲染完成之前，UI 就不会像之前那样显示错乱了。</p></article><div><span class="ant-tag ant-tag-geekblue">#<span>react</span></span><span class="ant-tag ant-tag-volcano">#<span>useEffect</span></span><span class="ant-tag ant-tag-error">#<span>useLayoutEffect</span></span></div><div class="ant-divider ant-divider-horizontal" role="separator"></div><div class="ant-divider ant-divider-horizontal" role="separator"></div><ins class=" adsbygoogle" style="display:block;text-align:center;width:100%;height:90px" data-ad-client="ca-pub-2087076429727327" data-ad-slot="9331479126" data-ad-layout="" data-ad-layout-key="" data-ad-format="auto" data-full-width-responsive="false"></ins></div><div class="container___8WoUM"><p class="title___3k8xL">Online Tools</p><div class="tool_tags___1ccK5"><span class="ant-tag ant-tag-blue tool_tag___1JT6M">JSON Formater</span><span class="ant-tag ant-tag-cyan tool_tag___1JT6M">MD5</span><span class="ant-tag ant-tag-error tool_tag___1JT6M">timestamps</span><span class="ant-tag ant-tag-green tool_tag___1JT6M">Cron Expresstion</span></div><div class="ant-divider ant-divider-horizontal" role="separator"></div><div style="text-align:center;height:300px"><ins class=" adsbygoogle" style="display:inline-block;width:250px;height:300px" data-ad-client="ca-pub-2087076429727327" data-ad-slot="7022357395" data-ad-layout="" data-ad-layout-key="" data-ad-format="auto" data-full-width-responsive="false"></ins></div><div class="ant-divider ant-divider-horizontal" role="separator"></div><div style="text-align:center;height:300px"><ins class=" adsbygoogle" style="display:inline-block;width:250px;height:300px" data-ad-client="ca-pub-2087076429727327" data-ad-slot="7022357395" data-ad-layout="" data-ad-layout-key="" data-ad-format="auto" data-full-width-responsive="false"></ins></div></div></div><footer class="footer___3wR6c">©2021 farmerlzj 提供技术支持 | 联系我们：farmerlzj@163.com |<!-- --> <a href="https://beian.miit.gov.cn/" rel="nofollow" target="_blank">蜀ICP备2021025378号-1</a></footer><div class="ant-back-top"></div></div>
	<script>
  window.g_useSSR = true;
  window.g_initialProps = {};
	</script>

    <script src="https://cloud.qianduan.shop/react.min.js"></script>
    <script src="https://cloud.qianduan.shop/react-dom.min.js"></script>
    <script src="/umi.js"></script>
    <script src="/layouts.js"></script>
    <script src="/p__blogs__detail__detail.js"></script>
  

</body></html>